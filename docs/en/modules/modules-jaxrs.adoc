= Jaxrs

To use the Jaxrs module, you just need to include a reference in pom.xml

[source,xml]
.pom.xml
----
<dependency>
    <groupId>hu.icellmobilsoft.roaster</groupId>
    <artifactId>roaster-jaxrs</artifactId>
</dependency>
----

== Using Jaxrs

The test files follow the JakartaEE JAX-RS specification,
The RestEasy implementation is used for all the containers.

=== RestAssured default settings

By default, XML or JSON format is supported in the system.

.JSON response settings

* A response HTTP status 200 and "application/json" accept.

.XML response settings

* The response HTTP status is 200 and "application/xml" accept.

=== ResponseProcessor

==== Implementation

To help you test a particular endpoint, the abstract class `hu.icellmobilsoft.roaster.jaxrs.response.ResponseProcessor` was created.
When deriving, the type of Response must be specified in a generic parameter,
and implement 2 methods returning String to identify the endpoint:

* `baseUriKey`: Key used in Roaster configuration to specify the baseUri of the endpoint
* `path`: The endpoint path. For example: http://localhost/foo/bar: /foo/bar

Optionally, other methods of the class can be overridden,
to customize the request or response folding.

==== Use of ====

Methods of the `ResponseProcessor` implementation `getOctetStream`, `postMultipartJson`, `postMultipartXml`, etc.
to call the endpoint and parse the response automatically.

=== ConfigurableResponseProcessor

In order to avoid having to implement a separate `ResponseProcessor` for each residual endpoint,
the `ConfigurableResponseProcessor` class is created, which reads the required values from configuration
such as `baseUriKey` and `path`.

==== Use of ====

The configuration should include `baseUriKey` and `path` under a common prefix.
Optionally, `headers` can be specified here.
For YAML format, this looks like this:

[source,yml]
----
    testsuite:
        rest:
            exampleService:
                example:
                    baseUriKey: example-project.example-service.url
                    path: /rest/exampleService/example/{id}
                headerExample:
                    baseUriKey: example-project.example-service.url
                    path: /rest/exampleService/example/{id}
                    headers:
                    - "X-LANGUAGE: en"
                    - "User-Agent: roaster/0.8 restassured"
----

In the test class, `ConfigurableResponseProcessor` is replaced by `@RestProcessor`
qualifier can be injected by specifying the config prefix:

[source,java]
----
import en.icellmobilsoft.roaster.jaxrs.response.producer.impl.ConfigurableResponseProcessor;

class ExampleTest {
    @Inject
    @RestProcessor(configKey = "testsuite.rest.exampleService.example") //<1>
    private ConfigurableResponseProcessor<ExampleResponse> responseProcessor;

    @Inject
    @RestProcessor(
        configKey = "testsuite.rest.exampleService.example",
        expectedStatusCode = HttpStatus.SC_BAD_REQUEST //<2>
    )
    private ConfigurableResponseProcessor<ExampleResponse> badRequestResponseProcessor;

    void test() {
        MultipartFormDataOutput multipartbody = new MultipartFormDataOutput();
        multipartbody.addFormData("part1", "part1Body", javax.ws.rs.core.MediaType.APPLICATION_JSON_TYPE);
        multipartbody.addFormData("part2", "part2Body", javax.ws.rs.core.MediaType.APPLICATION_JSON_TYPE);
        String response = processor.postMultipartJson(multipartbody, String.class, "jsonEntityId");
        Assertions.assertEquals(JsonUtil.toJson(RESPONSE_DTO), response);
    }
}
----
<1> Base `ConfigurableResponseProcessor` inject example
<2> Optionally, the expected response status code can be specified in the annotation (default: `200 OK`)
<3> In `ConfigurableResponseProcessor` you can also specify the query parameters

==== Own implementation

If you want to add the `ConfigurableResponseProcessor` to the project
(e.g. for login or other project specific header management),
you can do this by implementing `AbstractConfigurableResponseProcessor` as a first step:

[source,java]
----
import en.icellmobilsoft.roaster.jaxrs.response.producer.spi.AbstractConfigurableResponseProcessor;

@Dependent
public class CustomConfigurableResponseProcessor<RESPONSE> extends AbstractConfigurableResponseProcessor<RESPONSE> {

    // We overwrite what we need...
}
----

A CDI producer must then be created to serve the configured instances:

[source,java]
----
import en.icellmobilsoft.roaster.jaxrs.response.producer.spi.AbstractConfigurableResponseProcessorProducer;

@Dependent
public class CustomConfigurableResponseProcessorProducer<RESPONSE> extends AbstractConfigurableResponseProcessorProducer<LoginConfigurableResponseProcessor<RESPONSE>> {
    @Override
    @Produces //<1>
    @RestProcessor(configKey = "")
    public CustomConfigurableResponseProcessor<RESPONSE> createCustomResponseProcessor(InjectionPoint injectionPoint) {
        return super.createConfiguredResponseProcessor(injectionPoint);
    }

    @Override
    protected CustomConfigurableResponseProcessor<RESPONSE> getBaseResponseProcessor() { //<2>
        return CDI.current().select(CustomConfigurableResponseProcessor.class).get();
    }
}
----
<1> You need to create a producer (calling `createCustomResponseProcessor` will already give you a configured instance)
<2> You need to override `getBaseResponseProcessor` to return our type (this will be configured by `createCustomResponseProcessor`)

After that, you can use your own impelmentation, even with the default solution, in a test:

[source,java]
----
import en.icellmobilsoft.roaster.jaxrs.response.producer.impl.ConfigurableResponseProcessor;

class ExampleTest {
    @Inject
    @RestProcessor(configKey = "testsuite.rest.exampleService.example")
    private CustomConfigurableResponseProcessor<ExampleResponse> customResponseProcessor;
...
}
----

== Microprofile Rest Client
The Microprofile Rest Client itself uses the Jaxrs basics,
so jaxrs implementations also support it natively.
For RestEasy, for example, here:
https://docs.jboss.org/resteasy/docs/4.7.5.Final/userguide/html/MicroProfile_Rest_Client.html [MicroProfile Rest Client]
for a more specific description.

Roaster dependency provides support for the use of MicroProfile Rest Client.

.Simple MicroProfile Rest Client API sample
[source,java]
----
import javax.ws.rs.Consumes;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

import en.icellmobilsoft.coffee.dto.common.commonservice.BaseRequest;
import hu.icellmobilsoft.coffee.dto.exception.BaseException;

@RegisterRestClient
public interface TestMpRestApi {

    @POST
    @Path("/mp/rest/client/post")
    @Produces(value = { MediaType.APPLICATION_JSON })
    @Consumes(value = { MediaType.APPLICATION_JSON })
    String testPost(BaseRequest baseRequest) throws BaseException;
}
----

.MicroProfile Rest Using Client API
[source,java]
----
TestMpRestApi testMpRestApiImpl = RestClientBuilder.newBuilder()
    // set URI
    .baseUri(URI.create(System.getProperty(URI_KEY)))
    // build API interface
    .build(TestMpRestApi.class);
String response = testMpRestApiImpl.testPost(DtoHelper.createBaseRequest());
----

